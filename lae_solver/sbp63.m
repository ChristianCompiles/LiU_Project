function [P, D] = sbp63(N, dx)
%
%  Create a 6-3 SBP operator that is sixth order
%  in the interior with a third order boundary closure
%  on the interval [a,b].
%
%  This creates full matrices for ease of use but
%  could use sparse matrices if speed is desired
%  (see commented code at the end of the file).
%
%  Coefficients come from the paper where, note, the integration
%  matrix P is referred to as H:
%
%  Mattsson, Nordstr√∂m (2004)
%   "Summation by parts operators for finite difference 
%    approximations of second derivatives."
%   Journal of Computational Physics 199, pp. 503-540.
%  
%  INPUT:  N  - number of uniform discretization points
%          dx - grid spacing defined by (b-a) / (N-1) 
%
%  OUTPUT: P - integration matrix
%          D - derivative matrix
%

    % Check that it is possible to create the operator
    if N < 12
       error("Must use N >= 12 to construct the 6-3 SBP operator.")
    end

    % For convenience create P matrix and its inverse
    P = diag(ones(N,1),0);
    P(1:6, 1:6) = diag([13649/43200, ...
                        12013/8640, ...
                        2711/4320, ...
                        5359/4320, ...
                        7877/8640, ...
                        43801/43200]);
    % Reverse the order of the quadrature weights at the other boundary
    P(N-5:N, N-5:N) = fliplr(flipud(diag([13649/43200, ...
                                          12013/8640, ...
                                          2711/4320, ...
                                          5359/4320, ...
                                          7877/8640, ...
                                          43801/43200])));
    P = dx * P;
    % Pinv = diag(1 ./ diag(P)); % unused

    % Standard sixth order central stencil for the interior
    D =  1/60 * diag(ones(N-3,1), 3) ...
        -3/20 * diag(ones(N-2,1), 2) ...
        +3/4  * diag(ones(N-1,1), 1) ...
        -3/4  * diag(ones(N-1,1),-1) ...
        +3/20 * diag(ones(N-2,1),-2) ...
        -1/60 * diag(ones(N-3,1),-3);

    % Create the somewhat ugly boundary closures on the left
    D(1:6,1:9) = [-21600/13649, 104009/54596, 30443/81894, -33311/27298, 16863/27298, -15025/163788, 0, 0, 0; ...
                  -104009/240260, 0, -311/72078, 20229/24026, -24337/48052, 36661/360390, 0, 0, 0; ...
                  -30443/162660, 311/32532, 0, -11155/16266, 41287/32532, -21999/54220, 0, 0, 0; ...
                   33311/107180, -20229/21436, 485/1398, 0, 4147/21436, 25427/321540, 72/5359, 0, 0;...
                  -16863/78770, 24337/31508, -41287/47262, -4147/15754, 0, 342523/472620, -1296/7877, 144/7877, 0; ...
                   15025/525612, -36661/262806, 21999/87602, -25427/262806, -342523/525612, 0, 32400/43801, -6480/43801, 720/43801];

    % Reverse the order and flip the sign of the boundary closure on the right
    D(N-5:N,N-8:N) = flipud(fliplr(-D(1:6,1:9)));

    % Scale by the grid spacing
    D = D / dx;

    % Q = P*D; % unused to create the unweighted differencing matrix
end

%%
% original sparse implementation saved for reference.
    % P = diag(ones(N,1),0);
    % P(1:6,1:6)=diag([13649/43200,12013/8640,2711/4320,5359/4320,7877/8640, 43801/43200]);
    % P(N-5:N,N-5:N)=fliplr(flipud(diag([13649/43200,12013/8640, 2711/4320,5359/4320,7877/8640,43801/43200])));
    % P = dx*P;
    % % Pinv = sparse(inv(P)); % unused
    % 
    % 
    % D =  1/60 * diag(ones(N-3,1),3) ...
    %     -3/20 * diag(ones(N-2,1),2) ...
    %     +3/4  * diag(ones(N-1,1),1) ...
    %     -3/4  * diag(ones(N-1,1),-1) ...
    %     +3/20 * diag(ones(N-2,1),-2) ...
    %     -1/60 * diag(ones(N-3,1),-3);
    % 
    % D(1:6,1:9)=[-21600/13649, 104009/54596, 30443/81894, -33311/27298, 16863/27298, -15025/163788, 0, 0, 0; ...
    %             -104009/240260, 0, -311/72078, 20229/24026, -24337/48052, 36661/360390, 0, 0, 0; ...
    %             -30443/162660, 311/32532, 0, -11155/16266, 41287/32532, -21999/54220, 0, 0, 0; ...
    %              33311/107180, -20229/21436, 485/1398, 0, 4147/21436, 25427/321540, 72/5359, 0, 0;...
    %             -16863/78770, 24337/31508, -41287/47262, -4147/15754, 0, 342523/472620, -1296/7877, 144/7877, 0; ...
    %              15025/525612, -36661/262806, 21999/87602, -25427/262806, -342523/525612, 0, 32400/43801, -6480/43801, 720/43801];
    % D(N-5:N,N-8:N)=flipud(fliplr(-D(1:6,1:9)));
    % D = sparse(D / dx);
    % % Q = sparse(P * D); % unused